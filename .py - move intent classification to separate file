[1mdiff --git a/routes/vapi_routes.py b/routes/vapi_routes.py[m
[1mindex 3c47641..5b75b13 100644[m
[1m--- a/routes/vapi_routes.py[m
[1m+++ b/routes/vapi_routes.py[m
[36m@@ -1,27 +1,14 @@[m
 """[m
 VAPI AI webhook route handlers[m
 """[m
[31m-import os, re, json, time, uuid as uuidlib[m
 from flask import Blueprint, request, jsonify[m
 from typing import Dict, Any, Optional[m
 from config import Config[m
 from supabase import create_client[m
 from utils.logger import get_logger[m
[31m-from openai import OpenAI[m
 [m
 import requests[m
 [m
[31m-# --- ENV / clients for intent classification ---[m
[31m-OPENROUTER_API_KEY = os.environ.get("OPENROUTER_API_KEY")[m
[31m-OPENROUTER_BASE_URL = os.getenv("OPENROUTER_BASE_URL", "https://openrouter.ai/api/v1")[m
[31m-CLASSIFY_MODEL = os.getenv("CLASSIFY_MODEL", "anthropic/claude-3.5-sonnet")[m
[31m-TRANSLATE_MODEL = os.getenv("TRANSLATE_MODEL", "openai/gpt-4o-mini")[m
[31m-TOP_K = int(os.getenv("TOP_K", "7"))[m
[31m-[m
[31m-# Initialize OpenAI clients[m
[31m-emb_client = OpenAI(api_key=Config.OPENAI_API_KEY)[m
[31m-or_client = OpenAI(api_key=OPENROUTER_API_KEY, base_url=OPENROUTER_BASE_URL) if OPENROUTER_API_KEY else None[m
[31m-[m
 logger = get_logger(__name__)[m
 [m
 # Create blueprint[m
[36m@@ -1331,372 +1318,4 @@[m [mdef log_payload():[m
         [m
     except Exception as e:[m
         logger.error(f"Error in log-payload: {e}")[m
[31m-        return jsonify({'error': f'Internal server error: {str(e)}'}), 500[m
[31m-[m
[31m-# --- Intent Classification Helper Functions ---[m
[31m-[m
[31m-def _extract_last_user_text(conversation: str) -> str:[m
[31m-    if not conversation: return ""[m
[31m-    lines = [l.strip() for l in conversation.splitlines() if l.strip()][m
[31m-    if not lines: return ""[m
[31m-    last = lines[-1][m
[31m-    return re.sub(r"^(User|Caller|Customer|Agent|System)\s*[:\-]\s*", "", last, flags=re.I)[m
[31m-[m
[31m-def _redact_pii(s: str) -> str:[m
[31m-    if not s: return s[m
[31m-    s = re.sub(r"\b[\w.%+-]+@[\w.-]+\.[A-Za-z]{2,}\b", "[redacted-email]", s)[m
[31m-    s = re.sub(r"\b\+?\d[\d\s().-]{7,}\b", "[redacted-phone]", s)[m
[31m-    return s[m
[31m-[m
[31m-def _detect_language_simple(s: str) -> str:[m
[31m-    return "en" if re.match(r"^[\x00-\x7F]*$", s or "") else "unknown"[m
[31m-[m
[31m-def _json_string(obj) -> str:[m
[31m-    return json.dumps(obj, ensure_ascii=False)[m
[31m-[m
[31m-def translate_to_english(text: str) -> tuple[str, int]:[m
[31m-    if not text: return "", 0[m
[31m-    if not or_client:[m
[31m-        logger.warning("OpenRouter client not available for translation")[m
[31m-        return text, 0[m
[31m-    t0 = time.time()[m
[31m-    try:[m
[31m-        resp = or_client.chat.completions.create([m
[31m-            model=TRANSLATE_MODEL,[m
[31m-            messages=[[m
[31m-                {"role": "system", "content": "You are a translator. Translate user text to neutral English. Return only the translation."},[m
[31m-                {"role": "user", "content": text}[m
[31m-            ][m
[31m-        )[m
[31m-        latency_ms = int((time.time() - t0) * 1000)[m
[31m-        out = (resp.choices[0].message.content or "").strip() or text[m
[31m-        return out, latency_ms[m
[31m-    except Exception as e:[m
[31m-        logger.error(f"Translation failed: {e}")[m
[31m-        return text, 0[m
[31m-[m
[31m-def embed_english(text: str) -> tuple[list[float], int, str]:[m
[31m-    t0 = time.time()[m
[31m-    try:[m
[31m-        resp = emb_client.embeddings.create(model="text-embedding-3-small", input=text)[m
[31m-        latency_ms = int((time.time() - t0) * 1000)[m
[31m-        return resp.data[0].embedding, latency_ms, "text-embedding-3-small"[m
[31m-    except Exception as e:[m
[31m-        logger.error(f"Embedding failed: {e}")[m
[31m-        return [], 0, "text-embedding-3-small"[m
[31m-[m
[31m-def match_topk(client_id: str, vec: list[float], k: int) -> list[dict]:[m
[31m-    try:[m
[31m-        vapi_service = VAPIWebhookService()[m
[31m-        r = vapi_service.supabase.rpc("match_intents", {"client_row_id": client_id, "query_embedding": vec, "match_count": k}).execute()[m
[31m-        if r.error: raise RuntimeError(r.error.message)[m
[31m-        return r.data or [][m
[31m-    except Exception as e:[m
[31m-        logger.error(f"Vector match failed: {e}")[m
[31m-        return [][m
[31m-[m
[31m-def load_intents(intent_ids: list[str]) -> list[dict]:[m
[31m-    if not intent_ids: return [][m
[31m-    try:[m
[31m-        vapi_service = VAPIWebhookService()[m
[31m-        r = vapi_service.supabase.table("intent").select([m
[31m-            "id,name,description,category_id,action_policy_override,transfer_number_override,priority,routing_target"[m
[31m-        ).in_("id", intent_ids).execute()[m
[31m-        if r.error: raise RuntimeError(r.error.message)[m
[31m-        return r.data or [][m
[31m-    except Exception as e:[m
[31m-        logger.error(f"Load intents failed: {e}")[m
[31m-        return [][m
[31m-[m
[31m-def load_category(category_id: str | None) -> dict | None:[m
[31m-    if not category_id: return None[m
[31m-    try:[m
[31m-        vapi_service = VAPIWebhookService()[m
[31m-        r = vapi_service.supabase.table("intent_category").select([m
[31m-            "id,name,default_action_policy,transfer_number,priority"[m
[31m-        ).eq("id", category_id).single().execute()[m
[31m-        return None if getattr(r, "error", None) else r.data[m
[31m-    except Exception as e:[m
[31m-        logger.error(f"Load category failed: {e}")[m
[31m-        return None[m
[31m-[m
[31m-def get_curated_clarifier(a: str, b: str) -> str | None:[m
[31m-    try:[m
[31m-        vapi_service = VAPIWebhookService()[m
[31m-        cond = f"and(intent_id_a.eq.{a},intent_id_b.eq.{b}),and(intent_id_a.eq.{b},intent_id_b.eq.{a})"[m
[31m-        r = vapi_service.supabase.table("intent_clarifier").select("question,intent_id_a,intent_id_b").or_(cond).maybe_single().execute()[m
[31m-        return None if getattr(r, "error", None) else (r.data or {}).get("question")[m
[31m-    except Exception as e:[m
[31m-        logger.error(f"Get clarifier failed: {e}")[m
[31m-        return None[m
[31m-[m
[31m-def classify_with_openrouter(utter_en: str, candidates: list[dict], target_language: str | None) -> dict:[m
[31m-    if not or_client:[m
[31m-        logger.warning("OpenRouter client not available for classification")[m
[31m-        return {[m
[31m-            "best_intent_id": candidates[0]["id"] if candidates else None,[m
[31m-            "confidence": 0.5,[m
[31m-            "needs_clarification": False,[m
[31m-            "clarify_question": "",[m
[31m-            "alternatives": [],[m
[31m-            "latency_ms": 0,[m
[31m-            "model": "fallback",[m
[31m-            "request_id": None,[m
[31m-            "prompt_tokens": None,[m
[31m-            "completion_tokens": None[m
[31m-        }[m
[31m-    [m
[31m-    schema = {[m
[31m-        "name": "intent_classification",[m
[31m-        "strict": True,[m
[31m-        "schema": {[m
[31m-            "type": "object",[m
[31m-            "additionalProperties": False,[m
[31m-            "properties": {[m
[31m-                "best_intent_id": {"type": "string"},[m
[31m-                "confidence": {"type": "number", "minimum": 0, "maximum": 1},[m
[31m-                "needs_clarification": {"type": "boolean"},[m
[31m-                "clarify_question": {"type": "string", "default": ""},[m
[31m-                "alternatives": {[m
[31m-                    "type": "array",[m
[31m-                    "items": {[m
[31m-                        "type": "object",[m
[31m-                        "additionalProperties": False,[m
[31m-                        "properties": {[m
[31m-                            "intent_id": {"type": "string"},[m
[31m-                            "confidence": {"type": "number", "